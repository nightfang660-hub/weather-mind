# âš›ï¸ Quantum Intelligence Service - Deployment Guide

This guide explains how to deploy the **Quantum Weather Intelligence Service** on Google Colab (free GPU/TPU access) and connect it to your Weather-Clip application.

## Option 1: Running Locally (If you have Python installed)
1.  Navigate to `quantum_service/`.
2.  Install dependencies:
    ```bash
    pip install -r requirements.txt
    ```
3.  Run the server:
    ```bash
    python main.py
    ```
    The server will start on `http://localhost:8000`.

---

## Option 2: Running on Google Colab (Recommended for Performance)

Since the quantum simulation (Statevector) can be CPU intensive, running on Colab is ideal.

### Step 1: Create a Notebook
1.  Go to [Google Colab](https://colab.research.google.com/).
2.  Create a **New Notebook**.
3.  Change Runtime Type to **Python 3** (GPU is optional for Statevector, but good for future Aer-GPU usage).

### Step 2: Paste the Server Code
Copy the code below into a cell and run it. This installs dependencies, creates the files, and uses `ngrok` (or `localtunnel`) to expose the API publicly.

```python
# 1. Install Dependencies
!pip install fastapi uvicorn qiskit numpy pydantic pyngrok nest-asyncio

# 2. Define the Engine and App Logic (Inline for Colab)
import math
import numpy as np
from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from fastapi import FastAPI
from pydantic import BaseModel
import nest_asyncio
import uvicorn
from pyngrok import ngrok

# --- ENGINE ---
class QuantumWeatherEngine:
    def __init__(self):
        self.n_qubits = 5
        
    def normalize_param(self, value, min_val, max_val):
        norm = (value - min_val) / (max_val - min_val)
        return max(0.0, min(1.0, norm))

    def create_circuit(self, temp, humidity, pressure, wind, clouds):
        qc = QuantumCircuit(self.n_qubits)
        for i in range(self.n_qubits): qc.h(i)
        
        theta_temp = self.normalize_param(temp, -20, 50) * math.pi
        theta_hum = self.normalize_param(humidity, 0, 100) * math.pi
        theta_press = self.normalize_param(pressure, 900, 1100) * math.pi
        theta_wind = self.normalize_param(wind, 0, 100) * math.pi
        theta_cloud = self.normalize_param(clouds, 0, 100) * (math.pi / 2)

        qc.rx(theta_temp, 0)
        qc.ry(theta_hum, 1)
        qc.rz(theta_press, 2)
        qc.p(theta_wind, 3)
        qc.cry(theta_cloud, 3, 4) 
        qc.cx(0, 1)
        qc.cx(2, 3)
        qc.cx(1, 2)
        qc.cx(3, 4)
        qc.cx(4, 0)
        return qc

    def analyze(self, weather_data):
        qc = self.create_circuit(
            weather_data['temperature'],
            weather_data['humidity'],
            weather_data['pressure'],
            weather_data['wind'],
            weather_data['clouds']
        )
        state = Statevector.from_instruction(qc)
        probs = state.probabilities()
        
        storm_prob = sum(p for i, p in enumerate(probs) if bin(i).count('1') >= 3)
        rain_confidence = sum(p for i, p in enumerate(probs) if (i & 3) == 3) * 2.5
        chaos_index = 1.0 - max(probs)
        reliability = max(0.1, 1.0 - chaos_index)
        dominant_state = np.argmax(probs)
        binary_state = f"{dominant_state:05b}"
        
        insights = {
            "00000": "Stable and Calm",
            "11111": "Super-Cell Storm Imminent",
            "10101": "Unstable High Pressure Front",
            "01010": "Humid Low Pressure System",
        }
        insight_msg = insights.get(binary_state, f"Complex Quantum State detected (Vector |{binary_state}âŸ©). Atmosphere in superposition.")

        return {
            "storm_probability": min(1.0, storm_prob),
            "rain_confidence": min(1.0, rain_confidence),
            "atmospheric_chaos": min(1.0, chaos_index),
            "forecast_reliability": min(1.0, reliability),
            "quantum_summary": insight_msg
        }

# --- APP ---
app = FastAPI()
q_engine = QuantumWeatherEngine()

class WeatherInput(BaseModel):
    temperature: float
    humidity: float
    pressure: float
    wind: float
    clouds: float
    rain: float

@app.post("/quantum/analyze")
async def analyze_weather(data: WeatherInput):
    return q_engine.analyze(data.dict())

# 3. Start Server with NGROK
# Replace 'YOUR_AUTHTOKEN' with your actual ngrok token if you want a persistent URL
# !ngrok config add-authtoken YOUR_AUTHTOKEN 

public_url = ngrok.connect(8000)
print(f"\nðŸš€ QUANTUM SERVICE LIVE AT: {public_url}\n")

nest_asyncio.apply()
uvicorn.run(app, port=8000)
```

### Step 3: Connect to App
1.  Copy the `https://xxxx.ngrok-free.app` URL generated by the cell above.
2.  In your `server/server.js` (or `.env` if configured), update the `QUANTUM_API_URL` to point to this address.
    *   *Note: For this demo, the app currently defaults to `http://localhost:8000` or looks for `QUANTUM_API_URL` env var.*
